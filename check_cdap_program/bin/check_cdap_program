#!/usr/bin/env bash

# Copyright Â© 2015 Cask Data, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may not
# use this file except in compliance with the License. You may obtain a copy of
# the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations under
# the License.


function usage() {
  cat <<EOF

Nagios-style plugin to check status of CDAP Programs

Requirements:
  curl

Usage: $0 [-hv] [-t timeout] -u <uri> [-n <namespace>] [-f <app.name>] 
         [-m <app.name>] [-s <app.name>] [-S <app.name>] [-w <app.name>]
         [-W <app.name>]

Options:
  -h			Usage info
  -u <uri>		CDAP Router endpoint to check
  -n <namespace>        CDAP Namespace to query
  -f <app.flows>        CDAP target Flow to check. Each Flow must be prepended
                        with the Application name and delimited with a period.
                        Multiple Application.Flow pairs can be specified as a
                        comma-separated list
  -m <app.mapreduce>    CDAP target MapReduce to check. Each MapReduce must be
                        prepended with the Application name and delimited with
                        a period. Multiple Application.MapReduce pairs can be
                        specified as a comma-separated list
  -s <app.services> 	CDAP target Service to check. Each Service must be
                        prepended with the Application name and delimited with
                        a period. Multiple Application.Service pairs can be
                        specified as a comma-separated list
  -S <app.spark>        CDAP target Spark jobs to check. Each Spark job must be
                        prepended with the Application name and delimited with
                        a period. Multiple Application.Spark pairs can be
                        specified as a comma-separated list
  -w <app.workflows>    CDAP target Workflow to check. Each Workflow must be
                        prepended with the Application name and delimited with
                        a period. Multiple Application.Workflow pairs can be
                        specified as a comma-separated list
  -W <app.workers>      CDAP target Workers to check. Each Worker must be
                        prepended with the Application name and delimited with
                        a period. Multiple Application.Worker pairs can be
                        specified as a comma-separated list
  -t <timeout>		override default timeout (seconds)
  -v			verbose (debug) output

Example:
  $0 -u http://my.cdap.router.endpoint:10000 -n mynamespace -f MyApp.MyFlow
       -s MyApp.MyService1,MyApp.MyService2

EOF
}

# Option defaults
OPT_VERBOSE=''
OPT_URI=''
OPT_NAMESPACE='default'
OPT_FLOWS=''
OPT_MAPREDUCES=''
OPT_SERVICES=''
OPT_SPARKS=''
OPT_WORKFLOWS=''
OPT_WORKERS=''
OPT_TIMEOUT=30

API_VERSION='v3'

# Results
res_status=0
res_message=''

# Read in args
while getopts "hvu:f:m:s:S:w:W:t:" opt; do
  case $opt in
    h)
      usage
      exit 0
      ;;
    v)
      OPT_VERBOSE=1
      ;;
    u)
      OPT_URI=${OPTARG}
      ;;
    f)
      OPT_FLOWS=${OPTARG}
      ;;
    m)
      OPT_MAPREDUCES=${OPTARG}
      ;;
    s)
      OPT_SERVICES=${OPTARG}
      ;;
    S)
      OPT_SPARKS=${OPTARG}
      ;;
    w)
      OPT_WORKFLOWS=${OPTARG}
      ;;
    W)
      OPT_WORKERS=${OPTARG}
      ;;
    t)
      OPT_TIMEOUT=${OPTARG}
      ;;
    \?)
      echo "Invalid option supplied" >&2
      usage
      exit 1
      ;;
  esac
done

# Validate args
if [ -z "${OPT_URI}" ] ; then
  echo "ERROR: -u <uri> is required"
  usage
  exit 3
fi

if [ -z ${OPT_FLOWS} ] && [ -z ${OPT_MAPREDUCES} ] && [ -z ${OPT_SERVICES} ] && \
   [ -z ${OPT_SPARKS} ] && [ -z ${OPT_WORKFLOWS} ] && [ -z ${OPT_WORKERS} ] ; then
  echo "ERROR: Nothing to check. Please provide -f, -m, -s, -S, -w, or -W flags"
  usage
  exit 3
fi

# TODO: validate arguments to each of -f,-m,-s,-S,-w,-W are valid,
#         comma-separated program specifications

# Confirm that curl is installed
if [ ! "$(which curl)" != "" ] ; then
  echo "ERROR: curl must be installed and present in \$PATH" 
  usage
  exit 3
fi

# Convenience wrapper functions for get_program_status
#   Input:
#     Arg1: A single CDAP program specification: app-id.program-id
function get_flow_status {
  get_program_status $1 'flows'
}
function get_mapreduce_status {
  get_program_status $1 'mapreduce'
}
function get_service_status {
  get_program_status $1 'services'
}
function get_spark_status {
  get_program_status $1 'spark'
}
function get_workflow_status {
  get_program_status $1 'workflows'
}
function get_worker_status {
  get_program_status $1 'workers'
}

# Get CDAP Program status
#   Input:
#     Arg1: A single CDAP program specification: app-id.program-id
#     Arg2: API program-type: (flows, mapreduce, services, etc)
#   Output:
#     __curr_resp: trimmed response string, ie 'RUNNING', 'STOPPED', etc
function get_program_status {
  IFS='.' read __appname __flowname <<< "${1}"
  local __progtype=${2}
  local __status_url="${OPT_URI}/${API_VERSION}/namespaces/${OPT_NAMESPACE}/apps"\
"/${__appname}/${__progtype}/${__flowname}/status"
  cdap_curl_request ${__status_url}

  # Trim result to single status string
  __curr_resp=${__curr_resp%\"*}
  __curr_resp=${__curr_resp##*\"}
}

# Makes a curl request to CDAP API. Fails fast on any non-200 HTTP return code
#   Input:
#     Arg1: API endpoint url
#     ${OPT_VERBOSE}
#   Output:
#     ${__curr_resp}: response body, ie '{ "status":"RUNNING" }'
# TODO: add "token" option to pass an auth token header
# TODO: add "insecure" option to set -k here
function cdap_curl_request {
  local __url=${1}
  local __v_flag=''
  if [ -n "${OPT_VERBOSE}" ]; then
    __v_flag='-v'
  fi
  local __resp=`curl ${__v_flag} -k -s -m ${OPT_TIMEOUT} -w ' %{http_code}' ${__url}`
  local __exitcode=$?

  # Abort Unknown if failed curl execution
  if [[ ${__exitcode} -ne 0 ]] ; then
    echo "UNKNOWN: curl error with exit code ${__exitcode}, output: ${__resp}"
    exit 3
  fi

  # Handle per HTTP response code
  local __respcode=${__resp##* }
  case ${__respcode} in
    200)
      ;;
    401)
      echo "UNKNOWN: CDAP Authentication not currently supported: ${__resp}"
      exit 3
      ;;
    404)
      echo "CRITICAL: CDAP Endpoint not found ${__respcode}: ${__url}"
      exit 2
      ;;
    *)
      echo "UNKNOWN: unexpected HTTP response code ${__respcode}: ${__resp}"
      exit 3
      ;;
  esac

# "Return" body portion of response
__curr_resp=${__resp%% *}
}

# Records a single program status into the aggregate response
#   Input:
#     Arg1: A single CDAP program specification: app-id.program-id
#     Arg2: program status string, ie RUNNING, STOPPED, etc
#   Output:
#     ${res_message} update
#     ${res_status} update
function process_result {
  local __program=${1}
  local __status=${2}

  # Append to, or initialize, result message
  if [ -z ${res_message} ] ; then
    res_message=${__program}=${__status}
  else
    res_message=${res_message},${__program}=${__status}
  fi

  # Set cumulative exit status
  if [[ ! ${__status} =~ RUNNING ]] ; then
    res_status=2
  fi
}

# Begin main logic
# Check specified flows
IFS=',' read -ra __flows <<< "${OPT_FLOWS}"
for __flow in "${__flows[@]}"; do
  get_flow_status ${__flow} && process_result ${__flow} ${__curr_resp}
done

# Check specified MapReduces
IFS=',' read -ra __mapreduces <<< "${OPT_MAPREDUCES}"
for __mapreduce in "${__mapreduces[@]}"; do
  get_mapreduce_status ${__mapreduce} && process_result ${__mapreduce} ${__curr_resp}
done

# Check specified Services
IFS=',' read -ra __services <<< "${OPT_SERVICES}"
for __service in "${__services[@]}"; do
  get_service_status ${__service} && process_result ${__service} ${__curr_resp}
done

# Check specified Spark jobs
IFS=',' read -ra __sparks <<< "${OPT_SPARKS}"
for __spark in "${__sparks[@]}"; do
  get_spark_status ${__spark} && process_result ${__spark} ${__curr_resp}
done

# Check specified Workflows
IFS=',' read -ra __workflows <<< "${OPT_WORKFLOWS}"
for __workflow in "${__workflows[@]}"; do
  get_workflow_status ${__workflow} && process_result ${__workflow} ${__curr_resp}
done

# Check specified Workers
IFS=',' read -ra __workers <<< "${OPT_WORKERS}"
for __worker in "${__workers[@]}"; do
  get_worker_status ${__worker} && process_result ${__worker} ${__curr_resp}
done

# Prepend result message with status string
case $res_status in
  0)
    res_message="OK: ${res_message}"
    ;;
  1)
    res_message="WARN: ${res_message}"
    ;;
  2)
    res_message="CRITICAL: ${res_message}"
    ;;
  *)
    res_message="UNKNOWN: ${res_message}"
    ;;
esac

# Display result to user and exit
echo $res_message
exit $res_status
