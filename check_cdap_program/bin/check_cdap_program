#!/usr/bin/env bash

# Copyright Â© 2015 Cask Data, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may not
# use this file except in compliance with the License. You may obtain a copy of
# the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations under
# the License.


function usage() {
  cat <<EOF

Nagios-style plugin to check status of CDAP Programs

Requirements:
  curl

Usage: $0 [-hv] [-t timeout] -u <uri> [-n <namespace>] [-f <app.name>] 
         [-m <app.name>] [-s <app.name>] [-S <app.name>] [-w <app.name>]
         [-W <app.name>]

Options:
  -h			Usage info
  -u <uri>		CDAP Router endpoint to check
  -n <namespace>        CDAP Namespace to query
  -f <app.flows>        CDAP target Flow to check. Each Flow must be prepended
                        with the Application name and delimited with a period.
                        Multiple Application.Flow pairs can be specified as a
                        comma-separated list
  -m <app.mapreduce>    CDAP target MapReduce to check. Each MapReduce must be
                        prepended with the Application name and delimited with
                        a period. Multiple Application.MapReduce pairs can be
                        specified as a comma-separated list
  -s <app.services> 	CDAP target Service to check. Each Service must be
                        prepended with the Application name and delimited with
                        a period. Multiple Application.Service pairs can be
                        specified as a comma-separated list
  -S <app.spark>        CDAP target Spark jobs to check. Each Spark job must be
                        prepended with the Application name and delimited with
                        a period. Multiple Application.Spark pairs can be
                        specified as a comma-separated list
  -w <app.workflows>    CDAP target Workflow to check. Each Workflow must be
                        prepended with the Application name and delimited with
                        a period. Multiple Application.Workflow pairs can be
                        specified as a comma-separated list
  -W <app.workers>      CDAP target Workers to check. Each Worker must be
                        prepended with the Application name and delimited with
                        a period. Multiple Application.Worker pairs can be
                        specified as a comma-separated list
  -t <timeout>		override default timeout (seconds)
  -v			verbose (debug) output

Example:
  $0 -u http://my.cdap.router.endpoint:10000 -n mynamespace -f MyApp.MyFlow
       -s MyApp.MyService1,MyApp.MyService2

EOF
}

# Option defaults
verbose=''
uri=''
namespace='default'
flows=''
mapreduces=''
services=''
sparks=''
workflows=''
workers=''
timeout=30
api_version='v3'

# Results
res_status=0
res_message=''

# Read in args
while getopts "hvu:f:m:s:S:w:W:t:" opt; do
  case $opt in
    h)
      usage
      exit 0
      ;;
    v)
      verbose=1
      ;;
    u)
      uri=${OPTARG}
      ;;
    f)
      flows=${OPTARG}
      ;;
    m)
      mapreduces=${OPTARG}
      ;;
    s)
      services=${OPTARG}
      ;;
    S)
      sparks=${OPTARG}
      ;;
    w)
      workflows=${OPTARG}
      ;;
    W)
      workers=${OPTARG}
      ;;
    t)
      timeout=${OPTARG}
      ;;
    \?)
      echo "Invalid option supplied" >&2
      usage
      exit 1
      ;;
  esac
done

# Validate args
if [ -z "${uri}" ] ; then
  echo "ERROR: -u <uri> is required"
  usage
  exit 3
fi

if [ -z ${flows} ] && [ -z ${mapreduces} ] && [ -z ${services} ] && \
   [ -z ${sparks} ] && [ -z ${workflows} ] && [ -z ${workers} ] ; then
  echo "ERROR: Nothing to check. Please provide -f, -m, -s, -S, -w, or -W flags"
  usage
  exit 3
fi

#if [ -n ${flows} ] && 


# Confirm that curl is installed
if [ ! "$(which curl)" != "" ] ; then
  echo "ERROR: curl must be installed and present in \$PATH" 
  usage
  exit 3
fi


function get_flow_status {
  get_program_status $1 'flows'
}
function get_mapreduce_status {
  get_program_status $1 'mapreduce'
}
function get_service_status {
  get_program_status $1 'services'
}
function get_spark_status {
  get_program_status $1 'spark'
}
function get_workflow_status {
  get_program_status $1 'workflows'
}
function get_worker_status {
  get_program_status $1 'workers'
}

function get_program_status {
  IFS='.' read __appname __flowname <<< "${1}"
  __progtype=${2}
  __status_url="${uri}/${api_version}/namespaces/${namespace}/apps"\
"/${__appname}/${__progtype}/${__flowname}/status"
  cdap_curl_request ${__status_url}

  # Trim result to single status string
  __curr_resp=${__curr_resp%\"*}
  __curr_resp=${__curr_resp##*\"}
}

function cdap_curl_request {
  __url=${1}
  if [ -n "${verbose}" ]; then
    __v_flag='-v'
  else
    __v_flag=''
  fi
  __resp=`curl ${__v_flag} -k -s -m ${timeout} -w ' %{http_code}' ${__url}`
  __exitcode=$?

  # Abort Unknown if failed curl execution
  if [[ ${__exitcode} -ne 0 ]] ; then
    echo "UNKNOWN: curl error with exit code ${__exitcode}, output: ${__resp}"
    exit 3
  fi

  # Handle per HTTP response code
  __respcode=${__resp##* }
  case ${__respcode} in
    200)
      ;;
    401)
      echo "UNKNOWN: CDAP Authentication not currently supported: ${__resp}"
      exit 3
      ;;
    404)
      echo "CRITICAL: CDAP Endpoint not found ${__respcode}: ${__url}"
      exit 2
      ;;
    *)
      echo "UNKNOWN: unexpected HTTP response code ${__respcode}: ${__resp}"
      exit 3
      ;;
  esac

__curr_resp=${__resp%% *}
}

function process_result {
  __program=${1}
  __status=${2}

  # Append to, or initialize, result message
  if [ -z ${res_message} ] ; then
    res_message=${__program}=${__status}
  else
    res_message=${res_message},${__program}=${__status}
  fi

  # Set cumulative exit status
  if [[ ! ${__status} =~ RUNNING ]] ; then
    res_status=2
  fi
}


# Check flows
IFS=',' read -ra __flows <<< "${flows}"
for __flow in "${__flows[@]}"; do
  get_flow_status ${__flow} && process_result ${__flow} ${__curr_resp}
done

# Check MapReduces
IFS=',' read -ra __mapreduces <<< "${mapreduces}"
for __mapreduce in "${__mapreduces[@]}"; do
  get_mapreduce_status ${__mapreduce} && process_result ${__mapreduce} ${__curr_resp}
done

# Check Services
IFS=',' read -ra __services <<< "${services}"
for __service in "${__services[@]}"; do
  get_service_status ${__service} && process_result ${__service} ${__curr_resp}
done

# Check Spark jobs
IFS=',' read -ra __sparks <<< "${sparks}"
for __spark in "${__sparks[@]}"; do
  get_spark_status ${__spark} && process_result ${__spark} ${__curr_resp}
done

# Check Workflows
IFS=',' read -ra __workflows <<< "${workflows}"
for __workflow in "${__workflows[@]}"; do
  get_workflow_status ${__workflow} && process_result ${__workflow} ${__curr_resp}
done

# Check Workers
IFS=',' read -ra __workers <<< "${workers}"
for __worker in "${__workers[@]}"; do
  get_worker_status ${__worker} && process_result ${__worker} ${__curr_resp}
done

# Prepend result message with status string
case $res_status in
  0)
    res_message="OK: ${res_message}"
    ;;
  1)
    res_message="WARN: ${res_message}"
    ;;
  2)
    res_message="CRITICAL: ${res_message}"
    ;;
  *)
    res_message="UNKNOWN: ${res_message}"
    ;;
esac

# Display result to user and exit
echo $res_message
exit $res_status


# construct urls
STATUSURL="http://$host:$restport/$restendpoint/$application/$entityname/$entity/status"
METRICSQRY="[\"/reactor/apps/$application/$entityname/$metric?aggregate=true\"]"

# make the curl call
if [ -n "$verbose" ] ; then echo "request URL: $STATUSURL" ; fi
RESP=`curl -k -s -m $timeout -w ' CODE:%{http_code}' $STATUSURL`
EXITCODE=$?

if [ -n "$verbose" ] ; then echo "response: $RESP" ; fi

# check for failed curl execution 
if [[ $EXITCODE -ne 0 ]] ; then
    echo "UNKNOWN: curl error with exit code $EXITCODE, output: $RESP"
    exit 3
fi

# check http response code
if [[ ! $RESP =~ CODE:200 ]] ; then
    # non-200 http response code
    echo "UNKNOWN: non-OK http response code returned: $RESP"
    exit 3
else 
    # successful response, trim response code to leave status
    RESP=`echo "$RESP" | sed -e 's/ CODE:200$//'`
fi

# check the returned state
if [ -n "$verbose" ] ; then echo "returned state: $RESP" ; fi

if [[ ! $RESP =~ RUNNING ]] ; then
    # Flow is not in a running state
    echo "ERROR: Flow status: $RESP returned from $STATUSURL"
    exit 2
fi

# Flow is running, get performance data, does not fail on error
# For now, we query one top-level metric 
if [ -n "$verbose" ] ; then echo "metrics QRY: $METRICSQRY" ; fi
METRICS=`curl -s -X POST -H 'Content-Type: application/json' -d "$METRICSQRY" http://$host:$restport/v2/metrics`

# [{"path":"/reactor/apps/cms/flows/process.events?aggregate\u003dtrue","result":{"data":527739}}]
METRICNAME=$(echo $METRICS | sed 's/.*\/\(.*\)?.*/\1/g')
METRICDATA=$(echo $METRICS | sed 's/.*\"data\"\:\([0-9]*\).*/\1/g')
PERFDATA="|$application.$entity.$METRICNAME=$METRICDATA"

# return success, plus performance data

echo "OK: $entity running$PERFDATA"
exit 0


