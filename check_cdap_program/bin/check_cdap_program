#!/usr/bin/env bash

function usage() {
    cat <<EOF

Nagios-style plugin to check status of CDAP Programs

Requirements:
  curl

Usage: $0 [-hv] [-t timeout] -u <uri> [-n <namespace>] [-f <app.name>] 
         [-m <app.name>] [-s <app.name>] [-S <app.name>] [-w <app.name>]
         [-W <app.name>]

Options:
  -h			Usage info
  -u <uri>		CDAP Router endpoint to check
  -n <namespace>        CDAP Namespace to query
  -f <app.flows>        CDAP target Flow to check. Each Flow must be prepended
                        with the Application name and delimited with a period.
                        Multiple Application.Flow pairs can be specified as a
                        comma-separated list
  -m <app.mapreduce>    CDAP target MapReduce to check. Each MapReduce must be
                        prepended with the Application name and delimited with
                        a period. Multiple Application.MapReduce pairs can be
                        specified as a comma-separated list
  -s <app.services> 	CDAP target Service to check. Each Service must be
                        prepended with the Application name and delimited with
                        a period. Multiple Application.Service pairs can be
                        specified as a comma-separated list
  -S <app.spark>        CDAP target Spark jobs to check. Each Spark job must be
                        prepended with the Application name and delimited with
                        a period. Multiple Application.Spark pairs can be
                        specified as a comma-separated list
  -w <app.workflows>    CDAP target Workflow to check. Each Workflow must be
                        prepended with the Application name and delimited with
                        a period. Multiple Application.Workflow pairs can be
                        specified as a comma-separated list
  -W <app.workers>      CDAP target Workers to check. Each Worker must be
                        prepended with the Application name and delimited with
                        a period. Multiple Application.Worker pairs can be
                        specified as a comma-separated list
  -t <timeout>		override default timeout (seconds)
  -v			verbose (debug) output

Example:
  $0 -u http://my.cdap.router.endpoint:10000 -n mynamespace -f MyApp.MyFlow
       -s MyApp.MyService1,MyApp.MyService2

EOF
}

# option defaults
verbose=''
uri=''
flows=''
mapreduces=''
services=''
sparks=''
workflows=''
workers=''
timeout=30
api_version='v3'

# read in args
while getopts "hvu:f:m:s:S:w:W:t:" opt; do
    case $opt in
        h)
            usage
            exit 0
            ;;
        v)
            verbose=1
            ;;
        u)
            uri=$OPTARG
            ;;
        f)
            flows=$OPTARG
            ;;
        m)
            mapreduces=$OPTARG
            ;;
        s)
            services=$OPTARG
            ;;
        S)
            sparks=$OPTARG
            ;;
        w)
            workflows=$OPTARG
            ;;
        W)
            workers=$OPTARG
            ;;
        t)
            timeout=$OPTARG
            ;;
        \?)
            echo "Invalid option supplied" >&2
            usage
            exit 1
            ;;
    esac
done

# validate args
if [ -z "$host" ] ; then
    echo "Error: -H <host> is required"
    usage
    exit 3
fi

if [ -z "$application" ] ; then
    echo "Error: -a <application> is required"
    usage
    exit 3
fi

if [ -z "$flow" ] && [ -z "$query" ] ; then
    echo "Error: either -f <flow> or -q <query> is required"
    usage
    exit 3
fi

if [ -n "$flow" ] && [ -n "$query" ] ; then
    echo "Error: only one of -f <flow> or -q <query> can be specified"
    usage
    exit 3
fi

# determine entity (flow or query) to check.  technically, these are interchangeable
entity=""
if [ -n "$flow" ] ; then
    entity=$flow
    entityname="flows"
    metric="process.events"
else 
    entity=$query
    entityname="procedures"
    metric="query.requests"
fi

# confirm that curl is installed
if [ ! "$(which curl)" != "" ] ; then
  echo "ERROR: curl must be installed and present in \$PATH" 
  usage
  exit 3
fi

# construct urls
STATUSURL="http://$host:$restport/$restendpoint/$application/$entityname/$entity/status"
METRICSQRY="[\"/reactor/apps/$application/$entityname/$metric?aggregate=true\"]"

# make the curl call
if [ -n "$verbose" ] ; then echo "request URL: $STATUSURL" ; fi
RESP=`curl -k -s -m $timeout -w ' CODE:%{http_code}' $STATUSURL`
EXITCODE=$?

if [ -n "$verbose" ] ; then echo "response: $RESP" ; fi

# check for failed curl execution 
if [[ $EXITCODE -ne 0 ]] ; then
    echo "UNKNOWN: curl error with exit code $EXITCODE, output: $RESP"
    exit 3
fi

# check http response code
if [[ ! $RESP =~ CODE:200 ]] ; then
    # non-200 http response code
    echo "UNKNOWN: non-OK http response code returned: $RESP"
    exit 3
else 
    # successful response, trim response code to leave status
    RESP=`echo "$RESP" | sed -e 's/ CODE:200$//'`
fi

# check the returned state
if [ -n "$verbose" ] ; then echo "returned state: $RESP" ; fi

if [[ ! $RESP =~ RUNNING ]] ; then
    # Flow is not in a running state
    echo "ERROR: Flow status: $RESP returned from $STATUSURL"
    exit 2
fi

# Flow is running, get performance data, does not fail on error
# For now, we query one top-level metric 
if [ -n "$verbose" ] ; then echo "metrics QRY: $METRICSQRY" ; fi
METRICS=`curl -s -X POST -H 'Content-Type: application/json' -d "$METRICSQRY" http://$host:$restport/v2/metrics`

# [{"path":"/reactor/apps/cms/flows/process.events?aggregate\u003dtrue","result":{"data":527739}}]
METRICNAME=$(echo $METRICS | sed 's/.*\/\(.*\)?.*/\1/g')
METRICDATA=$(echo $METRICS | sed 's/.*\"data\"\:\([0-9]*\).*/\1/g')
PERFDATA="|$application.$entity.$METRICNAME=$METRICDATA"

# return success, plus performance data

echo "OK: $entity running$PERFDATA"
exit 0


